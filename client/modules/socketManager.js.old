// Socket.io is loaded from CDN in the HTML file
const io = window.io;

// Import constants for player positioning and THREE.js for color handling
import { GROUND_LEVEL, PLAYER_SIZE } from './constants.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';

export class SocketManager {
    constructor(playerName = 'Player') {
        this.socket = null;
        this.isConnected = false;
        this.gameManager = null;
        this.isPlayer1 = false; // Whether this client is player 1 (host)
        this.playerId = null;  // Unique ID for this player
        this.playerCount = 0;  // Initialize player count to 0
        
        // Ensure playerName is a string, not an HTML element
        if (playerName && typeof playerName === 'object' && playerName.textContent) {
            this.playerName = playerName.textContent;
        } else {
            this.playerName = String(playerName || 'Player');
        }
        
        this.playerCountElement = document.getElementById('playerCount');
        this.waitingMessageElement = document.getElementById('waitingMessage');
        this.playerNameElement = document.getElementById('playerName');
        
        // Make playerCount accessible globally for other components
        if (window) {
            window.currentPlayerCount = 0;
        }
        
        console.log('SocketManager initialized with player name:', this.playerName);
    }
    
    connect() {
        // Connect to the server
        this.socket = io();
        
        // Setup socket event handlers
        this.setupSocketEvents();
        
        console.log('Socket connection initiated');
    }
    
    setGameManager(gameManager) {
        this.gameManager = gameManager;
        console.log('Game manager set in SocketManager');
    }
    
    // Update player role display in UI
    updatePlayerRoleDisplay() {
        if (!this.waitingMessageElement) return;
        
        if (this.playerCount < 2) {
            this.waitingMessageElement.textContent = 'Waiting for another player to join...';
            this.waitingMessageElement.style.display = 'block';
        } else {
            this.waitingMessageElement.style.display = 'none';
        }
        
        // Update player count display
        if (this.playerCountElement) {
            this.playerCountElement.textContent = `Players: ${this.playerCount}/2`;
        }
        
        // Update global player count
        if (window) {
            window.currentPlayerCount = this.playerCount;
        }
    }
    
    // Create opponent player with proper color and position
    createOpponentPlayer(initialPosition = null) {
        if (!this.gameManager) {
            console.error('Cannot create opponent: gameManager not initialized');
            return null;
        }
        
        // Import Player class if needed
        const Player = window.Player || null;
        if (!Player) {
            console.error('Cannot create opponent: Player class not available');
            return null;
        }
        
        try {
            console.log('Creating opponent player...');
            
            // FIRST: Clean up any existing opponent cubes to avoid duplicates
            // 1. Remove opponent from game manager if it exists
            if (this.gameManager.opponent) {
                if (this.gameManager.opponent.cube) {
                    console.log('Removing existing opponent cube from scene');
                    this.gameManager.sceneManager.scene.remove(this.gameManager.opponent.cube);
                }
                this.gameManager.opponent = null;
            }
            
            // 2. Check for any stray opponent cubes in the scene and remove them
            if (this.gameManager.sceneManager && this.gameManager.sceneManager.scene) {
                const existingOpponentCubes = this.gameManager.sceneManager.scene.children.filter(obj => obj.name === 'OpponentCube');
                existingOpponentCubes.forEach(cube => {
                    console.log('Removing stray opponent cube from scene');
                    this.gameManager.sceneManager.scene.remove(cube);
                });
            }
            
            // 3. Create the opponent player with the correct color (isOpponent = true)
            const isOpponent = true;
            const opponent = new Player(
                this.gameManager.sceneManager.scene,
                isOpponent,
                this.gameManager.sceneManager.textureUtils,
                this.gameManager.soundManager
            );
            
            // 4. Set opponent position if provided
            if (initialPosition) {
                opponent.setPosition(initialPosition);
            } else {
                // Default position for opponent (opposite side of arena)
                opponent.position.x = -5;
                opponent.position.y = GROUND_LEVEL + PLAYER_SIZE/2;
                opponent.position.z = 0;
            }
            
            // 5. Force opponent cube color to red
            if (opponent.cube && opponent.cube.material) {
                opponent.cube.material.color.setHex(0xff0000); // Bright red
                console.log('Set opponent cube color to red');
            }
            
            // 6. Assign opponent to game manager
            this.gameManager.opponent = opponent;
            
            console.log('Opponent player created successfully');
            return opponent;
        } catch (error) {
            console.error('Error creating opponent player:', error);
            return null;
        }
    }
    
    setupSocketEvents() {
        // Connection established
        this.socket.on('connect', () => {
            this.isConnected = true;
            console.log('Connected to server');
            
            // Join the lobby with player name after connection
            setTimeout(() => {
                this.socket.emit('joinLobby', { name: this.playerName });
                console.log('Joined lobby as:', this.playerName);
            }, 500);
        });
        
        // Disconnection
        this.socket.on('disconnect', () => {
            this.isConnected = false;
            console.log('Disconnected from server');
        });
        
        // Player joined event - contains player info including role
        this.socket.on('playerJoined', (data) => {
            console.log('Player joined event received:', data);
            
            // Update player role
            if (data.id === this.socket.id) {
                this.isPlayer1 = data.isPlayer1 || data.role === 'player1';
                this.playerId = data.id;
                
                // Update player name in UI to include role
                if (this.playerNameElement) {
                    const roleText = this.isPlayer1 ? 'Player 1 (Host)' : 'Player 2';
                    
                    // Clean up the display name - remove any 'Player:' prefix
                    let displayName = this.playerName;
                    if (displayName.includes('Player:')) {
                        displayName = displayName.split('Player:')[1].trim();
                    }
                    
                    // Update UI with player name and role
                    this.playerNameElement.textContent = `${roleText}: ${displayName}`;
                }
                
                console.log(`You joined as: ${this.isPlayer1 ? 'Player 1 (Host)' : 'Player 2'}`);
                
                // Update player role display in UI
                this.updatePlayerRoleDisplay();
            }
        });
        
        // Player count update (legacy event)
        this.socket.on('playerCount', (count) => {
            console.log('Player count update received:', count);
            
            // Store the player count both locally and globally
            this.playerCount = count;
            if (window) {
                window.currentPlayerCount = count;
            }
            
            if (this.playerCountElement) {
                this.playerCountElement.textContent = count;
            }
            
            // Show/hide waiting message based on player count
            if (this.waitingMessageElement) {
                if (count < 2) {
                    this.waitingMessageElement.style.display = 'block';
                    this.waitingMessageElement.textContent = 'Waiting for another player to join...';
                } else {
                    this.waitingMessageElement.style.display = 'none';
                }
            }
            
            // Create opponent player ONLY when a second player connects
            if (count >= 2 && this.gameManager) {
                try {
                    // Only create opponent if it doesn't exist yet
                    if (!this.gameManager.opponent) {
                        console.log('Creating opponent player - second player connected');
                        this.createOpponentPlayer();
                        console.log('Opponent created successfully, player count:', count);
                    }
                    
                    // Start the game if it's not already started and we have two players
                    if (!this.gameManager.isGameStarted) {
                        console.log('Two players connected, starting game...');
                        // Add a small delay to ensure everything is initialized
                        setTimeout(() => {
                            this.gameManager.startGame();
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error in player count handler:', error);
                }
            } else if (count < 2 && this.gameManager && this.gameManager.opponent) {
                try {
                    // Remove opponent when player count drops below 2
                    console.log('Removing opponent player - player disconnected');
                    if (this.gameManager.opponent.cube) {
                        this.gameManager.sceneManager.scene.remove(this.gameManager.opponent.cube);
                    }
                    this.gameManager.opponent = null;
                    console.log('Opponent removed successfully, player count:', count);
                } catch (error) {
                    console.error('Error removing opponent player:', error);
                }
            } else {
                console.log('No action needed for player count update, count:', count, 
                           'opponent exists:', Boolean(this.gameManager && this.gameManager.opponent));
            }
        });
        
        // Lobby update event - contains the full list of players
        this.socket.on('lobbyUpdate', (data) => {
            console.log('Lobby update received:', data);
            
            // Update player count from lobby data
            if (this.playerCountElement && data.players) {
                this.playerCountElement.textContent = data.players.length;
                this.playerCount = data.players.length;
            }
            
            // Show/hide waiting message based on player count
            if (this.waitingMessageElement && data.players) {
                this.waitingMessageElement.style.display = data.players.length < 2 ? 'block' : 'none';
            }
            
            // Start the game when both players are present
            if (data.players && data.players.length >= 2 && this.gameManager && !this.gameManager.isGameStarted) {
                console.log('Both players present, starting game...');
                
                // Create opponent player if needed
                if (!this.gameManager.opponent) {
                    console.log('Creating opponent player from lobby update');
                    this.createOpponentPlayer();
                }
                
                // Start the game with a short delay to ensure opponent is created
                setTimeout(() => {
                    this.gameManager.startGame(true);
                    
                    // Update UI elements
                    const animStatus = document.getElementById('animStatus');
                    if (animStatus) {
                        animStatus.textContent = 'Game Started!';
                        animStatus.style.color = 'green';
                    }
                    
                    // Update player role display
                    this.updatePlayerRoleDisplay();
                }, 500);
            }
        });
        
        // Handle player movement updates
        this.socket.on('move', (data) => {
            // Determine if this move event is from the opponent
            const isFromOpponent = (this.isPlayer1 && data.role === 'player2') || 
                                (!this.isPlayer1 && data.role === 'player1');
                                
            if (isFromOpponent && this.gameManager) {
                // If opponent doesn't exist yet, create it dynamically with initial position
                if (!this.gameManager.opponent) {
                    console.log('Creating opponent dynamically from move event');
                    this.createOpponentPlayer(data);
                } else if (this.gameManager.opponent.cube) {
                    // Update existing opponent position
                    this.gameManager.opponent.setPosition(data);
                    
                    // Verify the opponent cube is red after position update
                    if (this.gameManager.opponent.cube.material) {
                        this.gameManager.opponent.cube.material.color.setHex(0xff0000); // Force red color
                    }
                    
                    // Log occasional position updates for debugging
                    if (Math.random() < 0.05) {
                        console.log('Received opponent position update:', data);
                    }
                } else {
                    console.error('Opponent exists but has no cube, recreating opponent');
                    this.createOpponentPlayer(data);
                }
            }
            
            // Handle opponent creation and removal based on player count in lobby updates
            if (this.gameManager) {
                // Create opponent player if there are two players and opponent doesn't exist yet
                if (data.players && data.players.length >= 2 && !this.gameManager.opponent) {
                    console.log('Creating opponent player from lobby update');
                    this.createOpponentPlayer();
                } 
                // Remove opponent if player count drops to 1
                else if (data.players && data.players.length < 2 && this.gameManager.opponent) {
                    console.log('Removing opponent player as player count dropped to 1');
                    try {
                        // Remove opponent cube from scene
                        if (this.gameManager.opponent.cube) {
                            this.gameManager.sceneManager.scene.remove(this.gameManager.opponent.cube);
                        }
                        // Clear opponent reference
                        this.gameManager.opponent = null;
                    } catch (error) {
                        console.error('Error removing opponent player:', error);
                    }
                }
            }
        });
        
        // Obstacle synchronization events
        // Handle obstacle created by Player 1
        this.socket.on('obstacleCreated', (obstacleData) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received obstacle data from Player 1:', obstacleData);
                // Create the obstacle in Player 2's game
                this.gameManager.obstacleManager.createObstacleFromData(obstacleData);
            }
        });
        
        // Handle full obstacle sync from Player 1
        this.socket.on('syncObstacles', (allObstacles) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received full obstacle sync from Player 1:', allObstacles.length, 'obstacles');
                // Sync all obstacles in Player 2's game
                this.gameManager.obstacleManager.syncObstaclesFromData(allObstacles);
            }
        });
        
        // Player role assignment event
        this.socket.on('playerRole', (data) => {
            // Handle both formats of role data (for compatibility)
            if (data.role !== undefined) {
                this.isPlayer1 = data.role === 'player1';
            } else if (data.isPlayer1 !== undefined) {
                this.isPlayer1 = data.isPlayer1;
            }
            
            this.playerId = data.playerId || this.socket.id;
            const roleText = this.isPlayer1 ? 'Player 1 (Host)' : 'Player 2';
            console.log(`Assigned role: ${roleText}`);
            
            // Update player name in UI to include role
            if (this.playerNameElement) {
                // Get current player name without any role prefix
                let displayName = this.playerName;
                if (displayName.includes('Player:')) {
                    displayName = displayName.split('Player:')[1].trim();
                }
                
                // Update UI with player name and role
                this.playerNameElement.textContent = `${roleText}: ${displayName}`;
            }
            
            // Update player role display in UI
            this.updatePlayerRoleDisplay();
            
            // Start the game with the assigned role
            if (this.gameManager) {
                try {
                    // Make sure all required components are initialized
                    if (!this.gameManager.sceneManager || !this.gameManager.player) {
                        console.warn('Cannot start game: required components not initialized');
                        return;
                    }
                    
                    // FIRST: Clean up any existing opponent cubes to avoid duplicates
                    // 1. Remove opponent from game manager if it exists
                    if (this.gameManager.opponent) {
                        if (this.gameManager.opponent.cube) {
                            console.log('Removing existing opponent cube from scene');
                            this.gameManager.sceneManager.scene.remove(this.gameManager.opponent.cube);
                        }
                        this.gameManager.opponent = null;
                    }
                    
                    // 2. Check for any stray opponent cubes in the scene and remove them
                    const existingOpponentCubes = this.gameManager.sceneManager.scene.children.filter(obj => obj.name === 'OpponentCube');
                    existingOpponentCubes.forEach(cube => {
                        console.log('Removing stray opponent cube from scene');
                        this.gameManager.sceneManager.scene.remove(cube);
                    });
                    
                    // 3. Ensure local player cube is blue
                    if (this.gameManager.player && this.gameManager.player.cube && this.gameManager.player.cube.material) {
                        this.gameManager.player.cube.material.color.setHex(0x0000ff); // Force blue color
                        console.log('Forced player cube color to blue');
                    }
                    
                    // 4. Create opponent player if we have 2 players
                    if (this.playerCount >= 2) {
                        console.log('Creating opponent player after role assignment');
                        const opponent = this.createOpponentPlayer();
                        
                        // Double-check the opponent color
                        if (opponent && opponent.cube && opponent.cube.material) {
                            opponent.cube.material.color.setHex(0xff0000); // Force red color
                            console.log('Forced opponent cube color to red during role assignment');
                        }
                    }
                    
                    // Force scene background color
                    if (this.gameManager.sceneManager && this.gameManager.sceneManager.scene) {
                        this.gameManager.sceneManager.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                    }
                    
                    // Force renderer clear color
                    if (this.gameManager.sceneManager && this.gameManager.sceneManager.renderer) {
                        this.gameManager.sceneManager.renderer.setClearColor(0x87CEEB, 1); // Sky blue
                        
                        // Force a manual render to ensure the scene appears
                        this.gameManager.sceneManager.renderer.render(
                            this.gameManager.sceneManager.scene,
                            this.gameManager.sceneManager.camera
                        );
                    }
                    
                    // Start the game with appropriate delay based on player role
                    const delay = this.isPlayer1 ? 1000 : 1500; // Longer delay for Player 2
                    setTimeout(() => {
                        this.gameManager.startGame(this.isPlayer1);
                        console.log(`${roleText} game started successfully`);
                    }, delay);
                } catch (error) {
                    console.error('Error starting game:', error);
                }
            } else {
                console.error('Cannot start game: gameManager not initialized');
            }
        });

        // Handle obstacle created by Player 1
        this.socket.on('obstacleCreated', (obstacleData) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received obstacle data from Player 1:', obstacleData);
                // Create the obstacle in Player 2's game
                this.gameManager.obstacleManager.createObstacleFromData(obstacleData);
            }
        });
        
        // Handle full obstacle sync from Player 1
        this.socket.on('syncObstacles', (allObstacles) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received full obstacle sync from Player 1:', allObstacles.length, 'obstacles');
                // Sync all obstacles in Player 2's game
                this.gameManager.obstacleManager.syncObstaclesFromData(allObstacles);
            }
        });
        
        // Handle player movement updates
        this.socket.on('move', (data) => {
            // Determine if this move event is from the opponent
            const isFromOpponent = (this.isPlayer1 && data.role === 'player2') || 
                                (!this.isPlayer1 && data.role === 'player1');
                                
            if (isFromOpponent && this.gameManager) {
                // If opponent doesn't exist yet, create it dynamically with initial position
                if (!this.gameManager.opponent) {
                    console.log('Creating opponent dynamically from move event');
                    this.createOpponentPlayer(data);
                } else if (this.gameManager.opponent.cube) {
                    // Update existing opponent position
                    this.gameManager.opponent.setPosition(data);
                    
                    // Verify the opponent cube is red after position update
                    if (this.gameManager.opponent.cube.material) {
                        this.gameManager.opponent.cube.material.color.setHex(0xff0000); // Force red color
                    }
                    
                    // Log occasional position updates for debugging
                    if (Math.random() < 0.05) {
                        console.log('Received opponent position update:', data);
                    }
                } else {
                    console.error('Opponent exists but has no cube, recreating opponent');
                    this.createOpponentPlayer(data);
                }
            }
        });
                                this.gameManager.soundManager
                            );
                            
                            // Assign the opponent to the game manager
                            this.gameManager.opponent = opponent;
                            
                            // Set the position immediately
                            this.gameManager.opponent.setPosition(data);
                            
                            console.log('Opponent created and positioned successfully');
                        }).catch(error => {
                            console.error('Failed to create opponent on position update:', error);
                        });
                    } else {
                        // Update existing opponent position
                        this.gameManager.opponent.setPosition(data);
                    }
                }
            }
        });
        
        // Obstacle created by player 1
        this.socket.on('obstacleCreated', (obstacleData) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received obstacle data from Player 1:', obstacleData);
                
                // Clear any existing obstacles first to ensure exact synchronization
                if (Array.isArray(obstacleData) && obstacleData.length > 0) {
                    // This is a batch update, clear existing obstacles first
                    this.gameManager.obstacleManager.clearObstacles();
                    
                    // Create each obstacle with exact position and rotation
                    obstacleData.forEach(data => {
                        const obstacle = this.gameManager.obstacleManager.createObstacle();
                        if (obstacle && data.position) {
                            obstacle.position.set(
                                data.position.x,
                                data.position.y,
                                data.position.z
                            );
                            
                            if (data.rotation) {
                                obstacle.rotation.set(
                                    data.rotation.x,
                                    data.rotation.y,
                                    data.rotation.z
                                );
                            }
                        }
                    });
                } else {
                    // Single obstacle update
                    const obstacle = this.gameManager.obstacleManager.createObstacle();
                    if (obstacle && obstacleData.position) {
                        obstacle.position.set(
                            obstacleData.position.x,
                            obstacleData.position.y,
                            obstacleData.position.z
                        );
                        
                        if (obstacleData.rotation) {
                            obstacle.rotation.set(
                                obstacleData.rotation.x,
                                obstacleData.rotation.y,
                                obstacleData.rotation.z
                            );
                        }
                    }
                }
            }
        });
        
        // Note: syncObstacles event handler is defined later in the code
        
        // Player hit event
        this.socket.on('playerHit', (data) => {
            console.log('Received playerHit event:', data);
            
            // Extract playerId from data object or use data directly if it's just the ID
            const hitPlayerId = data.playerId || data;
            
            // Only process opponent hit if:
            // 1. The hit player is not the local player
            // 2. We have a game manager
            // 3. There's an actual opponent object (meaning a second player is connected)
            // 4. We have at least 2 players in the game
            if (hitPlayerId !== this.playerId && 
                this.gameManager && 
                this.gameManager.opponent) {
                
                console.log('Opponent was hit, marking as hit');
                
                // Mark opponent as hit
                this.gameManager.opponent.markAsHit();
                
                // Play opponent hit sound
                if (this.gameManager.soundManager) {
                    this.gameManager.soundManager.playOpponentHitSound();
                }
                
                // Check if game is over
                this.gameManager.checkGameOver();
            } else if (hitPlayerId === this.playerId) {
                console.log('Received confirmation of our own hit');
            } else {
                console.warn('Ignoring playerHit event: no valid opponent or single player mode');
            }
        });
        
        // Reset game event
        this.socket.on('resetGame', () => {
            if (this.gameManager) {
                this.gameManager.resetGame();
            }
        });
        
        // Sync all obstacles from Player 1 (complete state synchronization)
        this.socket.on('syncObstacles', (obstacleData) => {
            if (!this.isPlayer1 && this.gameManager && this.gameManager.obstacleManager) {
                console.log('Received complete obstacle sync from Player 1:', obstacleData.length, 'obstacles');
                this.gameManager.obstacleManager.syncObstacleData(obstacleData);
            }
        });
    }
    
    // Emit player movement to server
    emitPlayerMove(position) {
        if (this.isConnected) {
            // Include player role and ID with position data
            const moveData = {
                ...position,
                role: this.isPlayer1 ? 'player1' : 'player2',
                playerId: this.playerId
            };
            this.socket.emit('move', moveData);
        }
    }
    
    // Update player role display in the UI
    updatePlayerRoleDisplay() {
        // Get player role element from the HTML
        const playerRoleElement = document.getElementById('playerRole');
        if (playerRoleElement) {
            // Set role text and style based on player role
            if (this.isPlayer1) {
                playerRoleElement.textContent = 'Player 1 (Host)';
                playerRoleElement.style.color = '#3498db'; // Blue for Player 1
            } else {
                playerRoleElement.textContent = 'Player 2';
                playerRoleElement.style.color = '#2ecc71'; // Green for Player 2
            }
            console.log(`Updated player role display: ${playerRoleElement.textContent}`);
        }
    }
    
    // Helper method to create opponent player
    createOpponentPlayer(initialPosition = null) {
        if (!this.gameManager) {
            console.error('Cannot create opponent: gameManager not initialized');
            return null;
        }
        
        try {
            // Use the Player class directly from window global
            // This avoids async issues with dynamic imports
            if (!window.Player) {
                console.error('Player class not available in window global');
                return null;
            }
            
            console.log('Creating opponent player with red color');
            
            // Remove any existing opponent first
            if (this.gameManager.opponent) {
                if (this.gameManager.opponent.cube) {
                    console.log('Removing existing opponent cube from scene');
                    this.gameManager.sceneManager.scene.remove(this.gameManager.opponent.cube);
                }
                this.gameManager.opponent = null;
            }
            
            // Check for any stray opponent cubes in the scene and remove them
            const existingOpponentCubes = this.gameManager.sceneManager.scene.children.filter(obj => obj.name === 'OpponentCube');
            existingOpponentCubes.forEach(cube => {
                console.log('Removing stray opponent cube from scene');
                this.gameManager.sceneManager.scene.remove(cube);
            });
            
            // Create a new opponent player
            const opponent = new window.Player(
                this.gameManager.sceneManager.scene,
                true, // isOpponent = true
                this.gameManager.textureUtils,
                this.gameManager.soundManager
            );
            
            // Double check the opponent cube was created properly
            if (!opponent.cube) {
                console.error('Opponent cube was not created properly');
                // Try to create it again
                opponent.createCube();
            }
            
            // Ensure the opponent cube is added to the scene
            if (opponent.cube && !this.gameManager.sceneManager.scene.children.includes(opponent.cube)) {
                console.log('Adding opponent cube to scene');
                this.gameManager.sceneManager.scene.add(opponent.cube);
            }
            
            // Force the opponent cube color to red
            if (opponent.cube && opponent.cube.material) {
                opponent.cube.material.color.setHex(0xff0000);
                console.log('Forced opponent cube color to red');
            }
            
            // Set initial position if provided
            if (initialPosition && opponent.setPosition) {
                console.log('Setting initial opponent position:', initialPosition);
                opponent.setPosition(initialPosition);
            } else {
                // Set a default position if none provided
                const defaultPosition = { x: 2, y: GROUND_LEVEL + (PLAYER_SIZE / 2), z: 0 };
                opponent.setPosition(defaultPosition);
                console.log('Set default opponent position:', defaultPosition);
            }
            
            // Store the opponent in the game manager
            this.gameManager.opponent = opponent;
            console.log('Opponent created successfully with red color');
            return opponent;
        } catch (error) {
            console.error('Error in opponent creation:', error);
            return null;
        }
    }
    
    // Emit player movement update to server
    emitPlayerMove(position) {
        if (this.socket && this.isConnected) {
            // Add player identification to position data
            const moveData = {
                ...position,
                playerId: this.playerId,
                role: this.isPlayer1 ? 'player1' : 'player2',
                timestamp: Date.now()
            };
            
            // Emit the move event with complete position data
            this.socket.emit('move', moveData);
        }
    }
    
    // Emit obstacle created event
    emitObstacleCreated(obstacleData) {
        if (this.socket && this.isPlayer1) {
            this.socket.emit('obstacleCreated', obstacleData);
        }
    }
    
    // Emit sync all obstacles event (for complete state synchronization)
    emitSyncObstacles(allObstacles) {
        if (this.socket && this.isPlayer1) {
            this.socket.emit('syncObstacles', allObstacles);
        }
    }
    
    // Emit player hit event to server
    emitPlayerHit() {
        if (this.isConnected) {
            // Send more complete information about the hit
            const hitData = {
                playerId: this.playerId,
                role: this.isPlayer1 ? 'player1' : 'player2',
                timestamp: Date.now()
            };
            console.log('Emitting player hit event:', hitData);
            this.socket.emit('playerHit', hitData);
        }
    }
    
    // Emit reset game event to server
    emitResetGame() {
        if (this.isConnected) {
            this.socket.emit('resetGame');
        }
    }
}
